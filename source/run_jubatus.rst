=====================
 Jubatusを使ってみる
=====================

まずはJubatusを起動して、実際にデータを流すところまで手を動かしてみましょう。
サンプルソースを読み解きながら、どのように使えば良いのかを解説します。


Jubatusを起動する
=================

ではJubatusを起動します。
先ほど説明した通り、Jubatusは複数の機械学習器を持っています。
今日使うのは、分類器(classifier)です。
Jubatusは機械学習器ごとに異なるコマンドで起動します。
分類器は ``jubaclassifier`` コマンドです。

分類器を起動してみましょう。
ターミナルから以下のコマンドを叩いてみてください。

::

  $ jubaclassifier -f /usr/local/share/jubatus/example/config/classifier/pa1.json

``-f`` で指定しているのは設定ファイルです。
デフォルトでサンプルの設定が配布されているので、そのサンプル設定を読み込ませています。
設定に関しては、次の章で解説します。
上記のコマンドでエラーが表示されなければjubaclassifierが起動しています。

起動しなかった場合は、別のプロセスが同じポートを利用している可能性があります。
利用するポートを変えるときは、 ``-p`` オプションを指定します。

::

  $ jubaclassifier -f /usr/local/share/jubatus/example/config/classifier/pa1.json -p 9200

jubaclassifierは学習や予測のクエリ（リクエスト）を受け取るまで、起動した状態で待機します。


サンプルを実行する
==================

まずは、サンプルプログラムを実行してみます。
以下のURLからサンプルプログラムをダウンロードしてください。

TODOサンプルプログラムのURLとwgetコマンドを書く

このサンプルは先ほどのjubaclassifierへ学習や予測のリクエスト（クエリー）を送信します。
では、実行してみましょう。

::

   $ python sample.py
   TODO 出力を表示

上記のような出力が出たら成功です。


サーバー・クライアントモデル
============================

先のプログラムがどのように動いているのかを通じて、Jubatusの仕組みを解説します。
Jubatusは最初に実行した ``jubaclassifier`` をはじめとするサーバーと、サンプルプログラムを始めとするクライアントからなります。
この仕組みのお陰で、C++で書かれたサーバーがデータの前処理から各種機械学習アルゴリズムの適用を担当し、一方ユーザーサイドのクライアントはPythonやJavaなどの複数の言語のものから選択できます。

クライアントとサーバー間の通信は、 *msgpack* というデータシリアライズ形式を使った *msgpack-rpc* を利用しています。
各言語用のクライアントライブラリは、msgpack-rpcをラップして隠蔽しているため、ユーザーは何の通信プロトコルを利用しているか知る必要はありません。
クライアントライブラリで用意されているメソッドを呼び出すだけで、自動的に通信を行い、分析結果が得られます。


サンプルプログラムを読んでみる
==============================

さて、ここから自分でプログラムを書いてみましょう。
まず手始めに、サンプルプログラムを読んでみます。
非常に単純なサンプルです。

::

   TODO

ここでは Python のソースをベースに説明します。
他の言語のサンプルも概ね同じような構造をしています。

簡単に説明します。
分類器の学習には、「このデータはこの分類がされます」という *教師データ* を与える必要があります。
教師データは *正解データ* 、 *ラベル付きデータ* と呼ばれることもあります。
最初の行で用意しているのが、この教師データです。
教師データを使って、 ``jubaclassifier`` の ``train`` メソッドを呼び出しています。
``train`` メソッドは、教師データを与えて分類器の構築あるいは更新を行うためのメソッドです。

学習のステップが終わったら、その学習済み分類器を使って未分類のデータを自動分類しています。
``classify`` メソッドは、未分類のデータを分類するためのメソッドです。
今まで学習したデータの傾向に照らしあわせて、学習された基準によって分類を行います。

分類結果は ``classification_result`` という型で返ってきます。
TODO

サンプルを改造してみる
======================

サンプルプログラムの改造を通して、使い方の感触を得ましょう。
一番簡単な改良として、学習データを増やしてみます。
一般的に、学習データは大量にあったほうが分類精度は良くなります。
以下のように、学習データを増やしてみます。

TODO

いくつかのデータに対して、分類結果が変わりました。

学習データは増やせば増やすほど、基本的には分類精度の向上が期待されます。
ただし、追加したデータが今までと違う傾向があったりすると、精度が向上するどころか下がることもあるので注意しましょう。


次に、ラベルを追加してみます。
今まで TODO と TODO だけの分類でしたが、 TODO を更に2つに分けて、以下のように細かい分類にしてみます。

TODO

先程と同様に実行してみましょう。

TODO

一般的にラベル数を増やせば増やすほど、見かけ上の精度は下がることに注意しましょう。
分類の粒度が細かくなればなるほど、正しく当てるのが難しくなるためです。


